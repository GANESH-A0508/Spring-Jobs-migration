Here’s a single, strong, ready-to-use prompt you can paste into an LLM and just fill in the placeholders (`{{...}}`):

---

**PROMPT START**

You are an expert senior Java/Spring Boot/Spring Batch developer and code-migration assistant.
Your job is to **migrate a single Spring Batch job** from one microservice (source project) into another microservice (destination project) **without breaking compilation or functionality**.

You have full read access to the file system for the given project paths.
You MUST read the actual source code and project structure before making any decisions. Do not guess.

---

## INPUTS

* **Source project root path**: `{{SOURCE_PROJECT_PATH}}`
* **Destination project root path**: `{{DESTINATION_PROJECT_PATH}}`
* **Job identifier** (job bean name / job config class / job name): `{{JOB_IDENTIFIER}}`

Assume both are typical Spring Boot/Spring Batch projects (Maven or Gradle).

---

## HIGH-LEVEL GOAL

Take the batch job identified by `{{JOB_IDENTIFIER}}` from the **source** project and migrate it into the **destination** project, so that:

1. The destination project **compiles successfully**.
2. The migrated job **behaves the same** as in the source project (no business logic changes).
3. The job fits naturally into the **existing architecture & conventions** of the destination project
   (package structure, configuration style, naming conventions, data sources, etc.).
4. All required supporting code (entities, repositories, configuration, readers/writers, listeners, schedulers, properties, etc.) is migrated or properly integrated.

---

## OVERALL PROCESS (YOU MUST FOLLOW THIS STEP BY STEP)

### 1. ANALYZE SOURCE PROJECT

1.1. Inspect `{{SOURCE_PROJECT_PATH}}` to understand:

* Build system: Maven (`pom.xml`) or Gradle (`build.gradle` / `build.gradle.kts`).
* Package structure under `src/main/java`.
* Batch configuration style:

  * Java config classes (`@Configuration` + `@EnableBatchProcessing`)
  * XML-based job definitions
* Location of properties: `application.properties`, `application.yml`, profile-specific configs.

1.2. Locate the **batch job** identified by `{{JOB_IDENTIFIER}}`:

* Find any `@Configuration` class(es) that define a `@Bean` of type `Job` whose name or job builder name matches `{{JOB_IDENTIFIER}}`, or whose job name equals `{{JOB_IDENTIFIER}}`.
* Also locate:

  * `Step` beans used by this job.
  * Custom readers, writers, processors, listeners, tasklets.
  * Any scheduled launchers (e.g., `@Scheduled` methods or Quartz config) related to this job.
  * Any `CommandLineRunner` or REST endpoints that trigger this job.
* Identify all **direct dependencies** of the job:

  * Entities, DTOs, repositories (`JpaRepository`, `CrudRepository`, etc.).
  * Services, domain components, utilities used in the job workflow.
  * Property keys (`@Value`, `Environment.getProperty`, etc.).
  * Data sources, transaction managers, and JobRepository configuration.

1.3. Build a **dependency map** for this job:

* List:

  * Job config classes
  * Step classes / methods
  * Readers/writers/processors/listeners
  * Entities and repositories
  * Services/domain classes
  * Property keys and profiles
  * DataSource / TransactionManager beans used by this job
* This map will drive which files and configs must be migrated or reused.

---

### 2. ANALYZE DESTINATION PROJECT

2.1. Inspect `{{DESTINATION_PROJECT_PATH}}` to understand:

* Build system and modules.
* Package naming conventions (base package, module structure).
* Existing Spring Batch configuration (if any):

  * Where `@EnableBatchProcessing` or batch configs live.
  * Existing JobRepository / JobLauncher beans.
  * How data sources are configured.
* Existing patterns for:

  * DataSource beans (naming, profiles, config properties).
  * Entities & repositories (package organization).
  * Properties (YAML vs properties, config server, profiles).
  * Scheduling (Spring `@Scheduled`, Quartz, external orchestrator).

2.2. From this, derive:

* **Target base package** for batch jobs.
* **Where to place new job config classes**.
* **Which existing DataSource / TransactionManager / JobRepository** should be used, or whether a new one must be created for this job.
* How cron expressions and job parameters are typically configured.

---

### 3. PLAN THE MIGRATION (BEFORE WRITING CODE)

Based on the analysis, create a **clear migration plan** for this single job:

3.1. Decide:

* Target package for the job config (e.g., `com.company.batch.jobs.orders`).
* Target packages for related entities/repositories/services if they must be moved.
* How to wire the job into the existing batch infrastructure:

  * Reuse an existing `JobRepository` / `JobLauncher` OR
  * Create a new `JobRepository` and `JobLauncher` bean, following destination patterns.

3.2. Decide configuration and properties:

* How to represent DB connections and any external endpoints:

  * Property names and structure (e.g., `spring.datasource`, `app.jobs.<name>.datasource`).
* Where to place properties (e.g., `application.yml`, profile-specific YAML, config server files).
* How to define any cron schedules or job triggers.

3.3. List all **files that need to be created or modified** in the destination project.

Only after you have a coherent plan should you generate or modify code.

---

### 4. PERFORM THE MIGRATION (CODE + CONFIG)

For each step, you must ensure the resulting code is compilable and consistent.

#### 4.1. Job & Step Configuration Classes

* Create or adapt a `@Configuration` class in the destination project that defines:

  * The `Job` bean for `{{JOB_IDENTIFIER}}` (you may rename the bean but must keep the job behavior identical).
  * All `Step` beans used by the job.
  * The correct injections (`JobBuilderFactory`, `StepBuilderFactory`, and any services/repositories).
* Adjust the package to the chosen target package, and update imports accordingly.
* Preserve **all business logic**: same flow, step order, conditional logic, listeners, and exception handling.

#### 4.2. Supporting Classes

* For each dependent class (reader, writer, processor, listener, tasklet, services, utilities, entities, repositories):

  * Decide whether to **move** it, **reuse** an equivalent one in destination, or **create an adapter**.
  * If moving: copy the class into a suitable package in the destination project and adjust the package/imports.
  * If reusing: update the job config to refer to the existing destination class.
  * If adapting: create minimal adapter classes that delegate to existing destination behavior.

* Ensure that all repository interfaces and entities are consistent with the destination’s existing JPA configuration (package scanning, base package, etc.).

#### 4.3. Data Sources and Transaction Management

* Determine how the job interacts with databases in the source project:

  * Which `DataSource` bean is it using?
  * Which schema/tables does it read/write?
* In the destination project:

  * Reuse an existing `DataSource` / `PlatformTransactionManager` when possible.
  * If needed, create a new `DataSource` / `TransactionManager` bean following destination conventions (no hard-coded credentials; use property placeholders).
* Wire the job’s Step(s) to the correct `TransactionManager`.

#### 4.4. Properties and Configuration

* Identify all property keys used by the job and its dependencies.
* In the destination project:

  * Add equivalent properties to the appropriate configuration file(s) (e.g., `application.yml` or profile-specific).
  * Use placeholders for secrets; do NOT hard-code passwords or tokens.
* If profiles are used (e.g., `dev`, `prod`), ensure the job configuration is profile-aware in a way that matches destination conventions.

#### 4.5. Scheduling / Triggering

* If the source job is scheduled (e.g., `@Scheduled`, Quartz), port this scheduling to the destination project:

  * Either create a new scheduling configuration class,
  * Or integrate into an existing scheduler configuration.
* Use the same cron expression by default unless destination conventions require configuration-driven cron.

---

### 5. ENSURE COMPILATION & FUNCTIONALITY

5.1. Verify imports and references:

* Ensure every class referenced from the migrated job exists in the destination project.
* Ensure package names and imports are correct.

5.2. Think through runtime behavior:

* Confirm that the same DB tables will be used (or explicitly note if different).
* Confirm that any file paths, queues, topics, or external APIs are properly configured.

5.3. Do NOT change business logic:

* Do not modify algorithms, conditional logic, business rules, or data mapping.
* Any unavoidable change must be explicitly documented as a note.

---

### 6. OUTPUT FORMAT

Your final answer MUST be structured as follows:

1. **Migration Summary**

   * Short description of what you did.
   * Which files/classes were migrated.
   * Which data source / repositories are used.

2. **Files Created or Modified** (very important)

   * For each file in the destination project:

     * Show:

       * `Destination path: <relative path from {{DESTINATION_PROJECT_PATH}}>`
       * Whether it is **new** or **modified**.
     * Then show the **full final content** of that file in a code block.
   * Do NOT omit file content for modified/created files.
   * If a file is too large and unchanged, just list it as “referenced but unchanged”.

3. **Configuration Changes**

   * Show YAML/properties snippets added/changed.
   * Mention which profile/file they belong to.

4. **Manual Action Items (if any)**

   * List anything that still needs human work:

     * Missing DB config
     * Potential schema differences
     * External systems requiring credentials
   * Be explicit and concrete.

5. **How to Run the Migrated Job**

   * Provide example command(s) to run the job from the destination project (e.g., Maven/Gradle or `java -jar` with parameters).
   * Mention any profiles or properties that must be set.

---

### IMPORTANT RULES

* **Always read the relevant source files first**; never invent classes or methods that don’t exist (unless you clearly mark them as new adapters).
* **Never leak credentials**. Use placeholders for any sensitive values.
* **Do not change business logic** — only adjust wiring, packages, and configuration to integrate with destination.
* If something is ambiguous or impossible to infer from the codebase, make a **clear best-effort assumption** and explicitly document that assumption in the final notes.

Now, using the actual code under `{{SOURCE_PROJECT_PATH}}` and `{{DESTINATION_PROJECT_PATH}}`, and the job identifier `{{JOB_IDENTIFIER}}`, perform this migration and produce the output in the specified format.

**PROMPT END**

---
